from flask import make_response
from oslo_log import log

from tunelo.api.schema import (
    KEY_BINDING_PROFILE,
    VALID_CHANNEL_TYPES,
    device_owner_pattern,
)
from tunelo.common.exception import MalformedChannel

LOG = log.getLogger(__name__)


def make_error_response(message=None, status_code=None):
    return make_response(
        {
            "error": message,
        },
        status_code,
    )


def create_channel_representation(port, peers=None):
    """Creates a JSON (dict) representation of a channel as described by the
    Channel Service design spec.

    While this is a super-set of the peer representation of a channel, all of the fields
    for a channel are derived manually in this function to ensure that the order
    of keys in the objects returned by the API are always the same.

    Args
        port: A dictionary which describes metadata of the port
            for which we are deriving a channel representation.
            This should be an un-modified reference to a dictionary
            returned by ``neutron_client.list_ports``
        peers (Optional): The peer channel(s) to which this channel is connected,
            if any.

    Returns: A ``dict`` containing the Channel's uuid, channel_type, peers, status,
    and properties.
    """
    return {
        "uuid": get_channel_uuid(port),
        "channel_type": get_channel_type(port),
        "peers": [create_spoke_peer_representation(peer) for peer in peers],
        "status": get_channel_status(port),
        "properties": get_channel_properties(port),
    }


def create_spoke_peer_representation(port):
    """Creates a simplified channel representation of a port for use in the ``'peers'``
    field of the channel representation. This is a subset of a channel description
    which provides a simplified view into a peer channel.

    Args:
        port: A dictionary which describes metadata of the port
            for which we are deriving a channel representation.
            This should be an un-modified reference to a dictionary
            returned by ``neutron_client.list_ports``

    Returns: A ``dict`` containing the peer's uuid, status, and properties.
    """
    return {
        "uuid": get_channel_uuid(port),
        "status": get_channel_status(port),
        "properties": get_channel_properties(port),
    }


def get_channel_properties(port):
    """Retreives a channel's binding:profile dict"""
    binding_profile = port["binding:profile"]
    ip = next(iter([fip["ip_address"] for fip in port["fixed_ips"]]), None)
    return {
        "public_key": binding_profile.get("public_key"),
        "endpoint": binding_profile.get("endpoint"),
        "ip": ip,
    }


def get_channel_type(port):
    """Resolves a channel's type as determined by its ``device_owner`` attribute
    as such:

    ``"channel:<channel_type>:(spoke|hub)"``

    Raises:
        MalformedChannel: If this channel has an invalid ``device_owner``
    """
    device_owner = get_channel_device_owner(port)
    valid_device_owner = device_owner_pattern.match(device_owner)
    if not valid_device_owner:
        raise MalformedChannel(
            f"Port {port['id']} has invalid device_owner: {device_owner}."
        )
    channel_type = valid_device_owner.group("channel_type")
    if channel_type not in VALID_CHANNEL_TYPES:
        raise MalformedChannel(f"Channel type '{channel_type}' is not supported.")
    return channel_type


def get_channel_network_id(port):
    return port["network_id"]


def get_channel_device_owner(port):
    return port["device_owner"]


def get_channel_uuid(port):
    return port["id"]


def get_channel_status(port):
    return port["status"]


def get_channel_project_id(port):
    return port["project_id"]


def match_spokes_to_hubs(spokes, hubs):
    """Gets a peers for a collection of spoke ports

    A peer for a spoke channel is, for now, defined as any hub channel which has
    a spoke's public key in its peers list.

    This function fetches peers for multiple spokes, which makes it more efficient
    for use in ListChannel.

    Args:
        spokes: An iterable of spoke port definitions, which are generated by
        ``neutron_client.get_ports()``
        hubs: An iterable of hub port definitions, which are generated by
        ``neutron_client.get_ports()``

    Raises:
        MalformedChannel: If a hub port has an invalid peer entry

    Returns:
        A dictionary, mapping spoke UUIDs to lists of hubs which have them as peers
    """
    if not spokes:
        return {}

    hub_map = {get_channel_uuid(hub): hub for hub in hubs}

    return {
        get_channel_uuid(spoke): [
            hub_map[hub_id]
            for hub_id in spoke[KEY_BINDING_PROFILE].get("peers", [])
            if hub_id in hub_map
        ]
        for spoke in spokes
    }
