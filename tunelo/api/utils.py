from flask import make_response
from oslo_log import log
from tunelo.api.channels import KEY_BINDING_PROFILE

from tunelo.api.schema import VALID_CHANNEL_TYPES
from tunelo.api.schema import device_owner_pattern
from tunelo.common.exception import MalformedChannel

LOG = log.getLogger(__name__)


def make_error_response(message=None, status_code=None):
    return make_response(
        {
            "error": message,
        },
        status_code,
    )


def create_channel_representation(port, peers=None):
    """Creates a JSON (dict) representation of a channel as described by the
    Channel Service design spec.

    While this is a super-set of the peer representation of a channel, all of the fields
    for a channel are derived manually in this function to ensure that the order
    of keys in the objects returned by the API are always the same.

    Args
        port: A dictionary which describes metadata of the port
            for which we are deriving a channel representation.
            This should be an un-modified reference to a dictionary
            returned by ``neutron_client.list_ports``
        peers (Optional): The peer channel(s) to which this channel is connected,
            if any.

    Returns: A ``dict`` containing the Channel's uuid, channel_type, peers, status,
    and properties.
    """
    return {
        "uuid": get_channel_uuid(port),
        "channel_type": get_channel_type(port),
        "peers": [create_spoke_peer_representation(peer) for peer in peers],
        "status": get_channel_status(port),
        "properties": get_channel_properties(port),
    }


def create_spoke_peer_representation(port):
    """Creates a simplified channel representation of a port for use in the ``'peers'``
    field of the channel representation. This is a subset of a channel description
    which provides a simplified view into a peer channel.

    Args:
        port: A dictionary which describes metadata of the port
            for which we are deriving a channel representation.
            This should be an un-modified reference to a dictionary
            returned by ``neutron_client.list_ports``

    Returns: A ``dict`` containing the peer's uuid, status, and properties.
    """
    return {
        "uuid": get_channel_uuid(port),
        "status": get_channel_status(port),
        "properties": get_channel_properties(port),
    }


def create_hub_peer_representation(spoke):
    """Creates a peer representation in the form of pubkey|endpoint|allowed_ips.
    This is how peers are listed in the ``peers`` attribute of a hub port's
    ``binding:profile``.

    Args:
        spoke: The spoke port that will be represented
    """
    spoke_props = get_channel_properties(spoke)
    pubkey = spoke_props.get("public_key") or ""
    endpoint = spoke_props.get("endpoint") or ""
    allowed_ips = ",".join([ip["ip_address"] for ip in spoke["fixed_ips"]])
    return f"{pubkey}|{endpoint}|{allowed_ips}"


def get_channel_properties(port):
    """Retreives a channel's binding:profile dict"""
    binding_profile = port["binding:profile"]
    ip = next(iter([fip["ip_address"] for fip in port["fixed_ips"]]), None)
    return {
        "public_key": binding_profile.get("public_key"),
        "endpoint": binding_profile.get("endpoint"),
        "ip": ip,
    }


def get_channel_type(port):
    """Resolves a channel's type as determined by its ``device_owner`` attribute
    as such:

    ``"channel:<channel_type>:(spoke|hub)"``

    Raises:
        MalformedChannel: If this channel has an invalid ``device_owner``
    """
    device_owner = get_channel_device_owner(port)
    valid_device_owner = device_owner_pattern.match(device_owner)
    if not valid_device_owner:
        raise MalformedChannel(
            f"Port {port['id']} has invalid device_owner: {device_owner}."
        )
    channel_type = valid_device_owner.group("channel_type")
    if channel_type not in VALID_CHANNEL_TYPES:
        raise MalformedChannel(f"Channel type '{channel_type}' is not supported.")
    return channel_type


def get_channel_network_id(port):
    return port["network_id"]


def get_channel_device_owner(port):
    return port["device_owner"]


def get_channel_uuid(port):
    return port["id"]


def get_channel_status(port):
    return port["status"]


def get_channel_project_id(port):
    return port["project_id"]


def get_channel_peers_spokes(spokes, hubs):
    """Gets a peers for a collection of spoke ports

    A peer for a spoke channel is, for now, defined as any hub channel which has
    a spoke's public key in its peers list.

    This function fetches peers for multiple spokes, which makes it more efficient
    for use in ListChannel.

    Args:
        spokes: An iterable of spoke port definitions, which are generated by
        ``neutron_client.get_ports()``
        hubs: An iterable of hub port definitions, which are generated by
        ``neutron_client.get_ports()``

    Raises:
        MalformedChannel: If a hub port has an invalid peer entry

    Returns:
        A dictionary, mapping spoke UUIDs to lists of hubs which have them as peers
    """
    if not spokes:
        return {}

    hub_map = {get_channel_uuid(hub): hub for hub in hubs}

    return {
        get_channel_uuid(spoke): [hub_map[hub_id] for hub_id in get_channel_peers(spoke) if hub_id in hub_map]
        for spoke in spokes
    }


def get_channel_peers(port):
    return port[KEY_BINDING_PROFILE].get("peers", [])


def filter_ports_by_device_owner(filter_regex, port_list):
    return [p for p in port_list if filter_regex.match(get_channel_device_owner(p))]
